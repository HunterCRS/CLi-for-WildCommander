           Файловая система FAT32.    
Данный текст основывается на документе
"FAT32 File System Specification"в котором
полностью описана файловая система FAT32.
   Здесь же мной рассмотены только главные
составляющие данной  файловой  системы,  с
достаточно подробными комментариями  осно-
ванными на  личном   опыте.  Так  же  мною
приведено  несколько   процедур,   которые
пригодятся при написании  собственного  ПО
для работы с FAT32.

Организация данных на жёстких дисках.

    В секторе с абсолютным номером 0 нахо-
дится  главная  загрузачная запись (Master
Boot Record - MBR)  в которой  расположена
таблица разделов (4  записи  каждая  по 16
байт)  хранящая  указатели на лог. разделы
диска.MBR сектор:
 Смещ.│Длин.
──────┼───────────────────────────────────
 +#000│ 446  - загрузочная запись MSB(NSB)
      │
 +#1BE│ 16   - описатель 1-го раздела
 +#1CE│ 16   - описатель 2-го раздела
 +#1DE│ 16   - описатель 3-го раздела
 +#1EE│ 16   - описатель 4-го раздела
      │
 +#1FE│ 2    - #55,#AA идентификатор
──────┴───────────────────────────────────

Формат 16-ти байтного описателя раздела:

 Смещ.│Длин.
──────┼───────────────────────────────────
   +0 │ 1    - признак активности
      │         #00 - не активен,
      │         #80 - активен
   +1 │ 1    - номер поверхности диска, с
      │        которой начинается раздел
   +2 │ 2    - Bit 0-5  - номер сектора
      │        Bit 8-15 - младшие 8 бит
      │                   номера цилиндра
      │        Bit 6-7  - старшие 2 бита
      │                   номера цилиндра
      │          (с них начинается раздел)
      │
   +4 │ 1    - код типа раздела(см. далее)
      │
   +5 │ 1    - номер поверхности диска на
      │        кот. заканчивается раздел
   +6 │ 2    - то же, что и в +2,  но  для
      │        конца раздела
      │
   +8 │ 4    - абсолютный номер первого
      │        сектора раздела (LBA режим)
   +12│ 4    - размер раздела в секторах
──────┴───────────────────────────────────

Коды типов разделов:

код    вид             размер         FAT
#01  Основной    0-15 Мбайт          FAT12
#04  Основной    16-32 Мбайт         FAT16
#05  Расширенный 0-2 Гбайт
#06  Основной    32 Мбайт - 2 Гбайт  FAT16
#0B  Основной    512 Мбайт - 2 Тбайт FAT32
#0C  Расширенный 512 Мбайт - 2 Тбайт FAT32
#0E  Основной    32 Мбайт - 2 Гбайт  FAT16
#0F  Расширенный 0-2 Гбайт

    Зачастую описатели разделов в MBR ука-
зывают не на сами разделы, а на начало це-
почки  SMBR. Это можно понять по коду типа
раздела ( +4(1)), если вид раздела на кот.
он  указывает "Расширенный" (см. таблицу),
то это означает, что мы прийдём к SMBR це-
почке, а не к разделу!
    Теперь  о самой FAT. Начну с BPB (BIOS
Parameter Block) сектора.

    Находится таковой в самом начале тома,
в резервном регионе. В  нём  хранятся  все
параметры  и  информация о том, что за FAT
находится в данном разделе.

BPB (первый сектор тома):
 Смещ.│Длин.
──────┼───────────────────────────────────
  +0  │ 3  - X
  +3  │ 8  - "MSWIN4.1"
  +11 │ 2  - количество байт в секторе
      │        (как правило 512)
. +13 │ 1  - секторов в кластере
. +14 │ 2  - кол-во секторов в резервном
      │      регионе, недопустимо = 0!
      │      Для FAT12 и FAT16 всегда = 1!
      │      Для FAT32 рекомендуется = 32
. +16 │ 1  - количество копий FAT
      │                       (обычно = 2)
  +17 │ 2  - для FAT32 = 0!
  +19 │ 2  - для FAT32 = 0!
  +21 │ 1  - X
  +22 │ 2  - для FAT32 = 0!
  +24 │ 2  - кол-во секторов на дорожке
  +26 │ 2  - кол-во голов у привода
  +28 │ 4  - кол-во секторов от начала
      │        раздела до данного тома FAT
  +32 │ 4  - количество секторов в томе
      │
. +36 │ 4  - длина в секторах первой копии
      │      FAT32
  +40 │ 2  - bit 0-3 - номер активной
      │                копии FAT32
      │          (имеет смысл если bit7=1)
      │      bit 4-6 - резерв
      │      bit 7   - принимает значения:
      │           0 если все копии FAT32
      │             являются активными
      │           1 если активной является
      │             одна из копий FAT32
      │      bit8-15 - резерв
  +42 │ 2  - номер версии файловой системы
. +44 │ 4  - номер первого кластера корне-
      │      вого каталога (с него начина-
      │      ется цепочка корневого ката.)
  +48 │ 2  - номер  сектора,  в  резервной
      │      зоне,  в  котором   находится
      │      структура FSINFO, как правило
      │      = 1 (то  бишь  сразу  за  BPB
      │      сектором  лежит  обычно  этот
      │      сектор,   описание    сектора
      │      FSINFO см. дальше)
  +50 │ 2  - номер  сектора,  в  резервной
      │      зоне,  в  котором   находится
      │      копия   BPB   сектора,    как
      │      правило = 6. Не рекомендуется
      │      заносить другие значения!
  +52 │ 12 - резерв (все байты должны =0!)
      │
  +64 │ 1  - номер привода
  +65 │ 1  - резерв (должно =0!)
  +66 │ 1  - если = #29, то можно смотреть
      │      следующие три записи
      │                    (+67, +71, +82)
      │
  +67 │ 4  - идентификационный номер тома
  +71 │ 11 - имя  тома  (обычно  его  ещё
      │      дублируют в начале корневого
      │      каталога)
      │
  +82 │ 8  - "FAT32   "
      │       (может содержать что угодно)
──────┴───────────────────────────────────
Точками я отметил поля котор. нужно сохра-
нить в памяти как переменные, т.к. таковые
постоянно нужны при работе с  FAT32. Также
в дальнейших обозначениях числа вида 14(2)
означают, что по смещ.  +14 находится  2-х
байтное число.

Формулы необходимые при работе с FAT32:

    Номер  первого  сектора области данных
(относительно  начала  тома)  считается по
формуле: FirstDataSec=14(2)+16(1)*36(4)    

Определение   номера  первого  сектора
кластера осущ. по следующей формуле:

FirstSecOfCluster=(N-2)*13(1)+FirstDataSec

 где N-номер кластера

Номера кластеров находятся в отрезке:
#00000002 - #0FFFFFF7

Кроме номеров кластеров в таблице FAT есть
управляющие коды, наиболее важные из них:

#00,#00,#00,#00 - свободный кластер
#FF,#FF,#FF,#0F - конец цепочки
#F7,#FF,#FF,#0F - поротый кластер   замечу,
что старшие 4-ре бита записей в
таблице FAT32 зарезервированы, как правило
их значения всегда нулевые.
 Хотя в документации по  FAT32  говорится,
что значения этих битов нельзя трогать...
При чтении их надо игнорировать, а при за-
писи прописывать туда теже  значения,  что
были! Т.е. хотим пометить кластер как сво-
бодный, а в нём было значение = #300001BA,
то нам нужно записать в  него  заначение =
#30000000!

Сама FAT начинается с двух записей:
    #F8,#FF,#FF,#0F
    #FF,#FF,#FF,#FF эти две записи являют-
ся  0м и 1м кластерами, но им в соответст-
вие  нету областей данных, поэтому по сме-
щению FirstDataSec находится первый сектор
второго кластера.
------------------------------------------

Определение FAT32:

    Для  начала  надо  убедиться в том что
перед  нами FAT. Для этого достаточно про-
верить строку по смещению +3 в BPB секторе
на  предмет, что там "MSWIN4.1". Для боль-
шей уверенности нужно также проверить кор-
ректность некоторых переменных:  11(2)=512
 - размер сектора 512 байт
  13(1)=1,2,4,8,16,32,64,128 - допустимые
                          размеры кластера
  14(2)<>0                    (в секторах)
  16(1)<>0
  17(2)=0
  19(2)=0
  22(2)=0
  36(4)<>0
  48(2)<>0

    Для  того  чтобы узнать, что это FAT32
нужно расчитать:
 DataSec=32(4)-FirstDataSec
  и
 CountOfClusters=DataSec/13(1)
  и если CountOfClusters >= 65525, то  это
FAT32!
------------------------------------------
Структура FSInfo:
    Т.к.  размер самой FAT (таблицы FAT) в
FAT32  зачастую  достаточно велик, поэтому
для  ускорения  работы  с HDD была введена
структура  FSInfo, которая содержит инфор-
мацию о количестве свободных кластеров и о
номере первого свободного кластера.
  (что-то наподобии 9-го сектора в TR-DOS)
FAT32 FSInfo Sector Structure:
 смещ.│длин.
──────┼───────────────────────────────────
  +0  │4   - #52,#52,#61,#41 идентификатор
  +4  │480 - резерв
  +484│4   - #72,#72,#41,#61 идентификатор
  +488│4   - кол-во свободных кластеров
  +492│4   - номер кластера с которого над
      │      начинать поиск свободных кла-
      │      стеров
  +496│12  - резерв
  +508│4   - #00,#00,#55,#AA
──────┴───────────────────────────────────
использование этого сектора может серьёзно
ускорить работу программы на запись, т. к.
поиск первого свободного кластера от нача-
ла FAT может затянуться.
------------------------------------------
Работа с каталогами/файлами:
    В  начале каждого каталога, кроме кор-
невого,  есть  две  записи (формат записей
каталога  см. далее) имена у таковых "." и
".."  соответственно. Первая является ука-
зателем  на католог в кот. находится. Вто-
рая  же  указывает  на каталог родитель (с
помощью этой записи можно вернуться в пре-
дыдущий каталог). Если номер  кластера  на
который указывает запись ".." равен  0, то
это значит, что каталог родитель  есть  ни
что иное как корневой каталог,  а  таковой
надо читать с кластера  который  указан  в
BPB секторе (смещение +44(4))
    Сами указатели на файлы/каталоги имеют
следующую структуру:

32 Byte Directory Entry Structure:
 название│смещ.│длин.
─────────┼─────┼──────────────────────────
DIR_Name │ +0  │11  - имя объекта
DIR_Attr │ +11 │1   - атрибуты объекта:
         │     │       bit 0 - тока чтение
         │     │       bit 1 - скрытый
         │     │       bit 2 - системный
         │     │       bit 3 - ID тома
         │     │       bit 4 - КАТАЛОГ
         │     │       bit 5 - архив
         │     │       bit6-7 - резерв
─────────┼─────┼──────────────────────────
         │ +12 │1 - резерв
─────────┼─────┼──────────────────────────
         │ +13 │1 - миллисекунды (0-199)
         │     │    (определяет  положение
         │     │    времени  между  двусе-
         │     │    кундными   интервалами
         │     │    которые   указаны    в
         │     │    DIRcTime)
DIRcTime │ +14 │2 - время создания файла
DIRcDate │ +16 │2 - дата создания файла
─────────┼─────┼──────────────────────────
         │ +18 │2 - дата последнего обра-
         │     │    щения к файлу
─────────┼─────┼──────────────────────────
DIRclusH │ +20 │2 - старшая часть номера
         │     │    первого кластера
─────────┼─────┼──────────────────────────
DIRwTime │ +22 │2 - время последней записи
DIRwDate │ +24 │2 - дата последней записи
─────────┼─────┼──────────────────────────
DIRclusL │ +26 │2 - младшая часть номера
         │     │    первого кластера
─────────┼─────┼──────────────────────────
DIRflSIZ │ +28 │4 - длина файла в байтах
         │     │(длина каталога всегда=0!)
─────────┴─────┴──────────────────────────
если  атрибуты "только чтение", "скрытый",
"системный",  "ID" установлены в 1, то это
означает,  что данная запись является час-
тью  длинного имени,  т. к.  для  обычного
файла все эти атрибуты  не  мобгут  прису-
тствовать  одновременно (описание  длинных
имён см. далее)Формат времени и даты:
 DIRwDate/DIRcDate имеют следующий формат:
  Bit 0-4 - день (принимает значения 1-31)
  Bit 5-8 - месяц (значения от 1 до 12)
  Bit 9-15 - год, нужно прибавлять 1980

DIRwTime/DIRcTime:
  Bit 0-4 - секунды(с точностью до 2 сек),
            принимает значения от 0 до 29,
            т.е. от 0 до 58 секунд
  Bit 5-10 - минуты, принимает значения
             от 0 до 59
  Bit 11-15- часы, допустимые значения
             от 0 до 23

    Более  точное время (в милли секундах)
находится  в  переменной  13(1), уточнение
для DIRcTime!
               (см. комментарий в таблице)    Код по  смещению  +0  является  первым
символом имени файла/каталога, но если  он
= #00/#05/#Е5, то:
 #00 - означает, что данная запись нахо-
       дится за пределами каталога, т.е.
       это код конца каталога
 #05 - код символа KANJI японского алфавит
 #E5 - признак того,  что элемент каталога
       удалён

Запрещёные коды в именах файлов/каталогов:
 #22,#2A,#2B,#2C,#2E,#2F
 #3A,#3B,#3C,#3D,#3E,#3F
 #5B,#5C,#5D,#7C
так же все коды < #20, за исключением #00,
#05 в первом символе имени.

Так же хочу обратить внимание на то, что в
каталоге  помимо обычных записей есть вся-
кий  мусор  -  куски  длинных имён файлов,
причём зачастую файлов к кот. они относят-
ся уже нет в данном каталоге...
    Поэтому  чтобы  отфильтровать всё это:
нужно  уже во время загрузки каталога про-
верять  первые три байта каждой записи пе-
ред  тем как перекидывать таковую в форми-
руемый каталог в памяти.
    Т.е.  если  значение хотябы в одном из
этих  байт  <  #20, то эта запись является
мусором,  если конечно в первом байте зна-
чения 0 нету
------------------------------------------
Длинные имена в FAT32:
    Длинные  имена  хранятся  в нескольких
элементах  каталога.  В  каждую 32 байтную
запись  помещается  13  очередных символов
имени,  коды  символов  хранятся в UNICOD,
т.е. два байта на символ.
    В  каталоге длинное имя должно находи-
ться перед коротким, причём порядок сегме-
нтов в которые разложены фрагменты длинно-
го  имени  идут  в  обратном порядке. Т.е.
сразу  за первой записью содержащей начало
длинного  имени  будет  запись  с коротким
именем файла. Схематично это выглядит так:
    ┌─────────────────────────────────┐
    │        Начало каталога          │
                  . . .
    ┌─────────────────────────────────┐
    │Последний фрагмент длинного имени│
    ├─────────────────────────────────┤
    │             . . .               │
    ├─────────────────────────────────┤
    │Второй фрагмент длинного имени   │
    ├─────────────────────────────────┤
    │Первый фрагмент длинного имени   │
    ├─────────────────────────────────┤
    │Стандартный описатель файла      │
    └─────────────────────────────────┘
                  . . .
    │        Конец каталога           │
    └─────────────────────────────────┘    
Формат элемента  каталога  содержащего
фрагмент длинного имени:

FAT Long Directory Entry Structure:
название │смещ.│длин.
─────────┼─────┼──────────────────────────
Ord      │ +0  │1 - номер этого сегмента в
         │     │    длинном имени, которое
         │     │    может содержать до  62
         │     │    таких частей
         │     │(т.е. для первого сегмента
         │     │этот  код  будет = 1,  для
         │     │второго = 2), но если  се-
         │     │гмент является  последним,
         │     │то Bit 6 = 1!
         │     │  т.е. если второй сегмент
         │     │ будет последним, то здесь
         │     │ значение будет = #42!
         │     │       (Bit 7 = 0 всегда!)
─────────┼─────┼──────────────────────────
Name1    │ +1  │10 - символы с 1 по 5-й
─────────┼─────┼──────────────────────────
Attr     │ +11 │1 - атрибуты
─────────┼─────┼──────────────────────────
Type     │ +12 │1 - #00
─────────┼─────┼──────────────────────────
ChkSum   │ +13 │1 -код CRC суммы короткого
         │     │   имени файла,  требуется
         │     │   для    привязки    этой
         │     │   цепочки длинного  имени
         │     │   к короткому имени файла
         │     │   (процедуру подсчёта CRC
         │     │    см. далее)
─────────┼─────┼──────────────────────────
Name2    │ +14 │12 - символы с 6 по 11-й
─────────┼─────┼──────────────────────────
FstClusL │ +26 │2 - #00,#00!
─────────┼─────┼──────────────────────────
Name3    │ +28 │4 - символы имени
         │     │    с 12 по 13-й
─────────┴─────┴──────────────────────────
    В  последнем сегменте после последнего
символа   длинного   имени   ставится  код
#00,#00.  Все  последующие  ячейки для UNI
символов забиваются кодом #FF,#FF!

Подсчёт ChkSum элемента каталога с
                           коротким именем:
GETCRC  XOR A
        LD B,11,HL,FileName
CRC     RRCA
        ADD A,(HL):INC HL
        DJNZ CRC
        RET
на выходе в A будет ChkSum.

контрольная  сумма  нужна  для того, чтобы
убедиться  в  том, что длинное имя находя-
щееся перед данным указателем на файл дей-
ствительно соответствует ему.
------------------------------------------
P.S.
    Если  вы  решили  реализовать работу с
FAT32,  то  по  началу будут очень полезны
следующие   несколько   процедур.  Таковые
производят  умножение и деление между 32-х
и 16-ти битными числами, так же есть проца
сложения  двух 32 битных чисел. Все проце-
дуры  проверены на практике и работают так
как задумано.;умножение
UMNOG   ;i:HL*BC
;        o:HL - результат
        LD DE,HL
        LD A,B,B,C,C,A:INC C
        XOR A:DEC B:JR Z,ODN
BSR     ADD HL,DE
        DJNZ BSR
ODN     LD B,A
        DEC C
        JR NZ,BSR
        RET;сложение двух 32 битных чисел
ADD4BF  ;i:[DE,HL]+[CLDE,CLHL]
;        o:[DE,HL]
        EX DE,HL
        LD BC,(CLDE)
        ADD HL,BC
        EX DE,HL
        LD BC,(CLHL)
        ADD HL,BC:JR NC,KNH
        INC DE
KNH     LD (CLHL),HL
        LD (CLDE),DE
        RET
CLHL    DS 2
CLDE    DS 2;деление 32 битного числа на 16 битное
;(процедура не полноценная, т.к. результат
;идёт в 16 битном числе)
DELIT4B ;i:[DE,HL]/BC
;        o:DE - целая часть, HL - остаток
        LD IX,0-1
        INC DE
NAZA    DEC DE
        OR A
DLTA    SBC HL,BC
        INC IX:JP NC,DLTA
        LD A,D:OR E:JP NZ,NAZA
        PUSH IX
        POP DE
        ADD HL,BC
        RET;умножение 32 битного числа на 16 битное
UMN4B   ;i:[DE,HL]*BC
;        o:[DE,HL]
        LD A,B,B,C,C,A:INC C
        OR A:JR NZ,TEKNO
        DEC B:JR Z,UMN1
        INC B
TEKNO   XOR A
        CP B:JR NZ,TYS
        DEC C
TYS     DEC B
        PUSH HL,BC
        LD HL,DE
        CP B:JR Z,NEGRY
EFRO    ADD HL,DE
        DJNZ EFRO
        LD B,A
NEGRY   DEC C:JR NZ,EFRO
        LD (REZDE),HL
        POP BC,HL
        LD DE,HL
        CP B:JR Z,NEGRA
OFER    ADD HL,DE
        JR C,INCDE
ENJO    DJNZ OFER
        LD B,A
NEGRA   DEC C:JR NZ,OFER
        LD DE,(REZDE)
UMN1    RET
INCDE   EXX
        LD HL,(REZDE)
        INC HL
        LD (REZDE),HL
        EXX
        JR ENJO
REZDE   DS 2
------------------------------------------
                         Budder/14.10.2006 